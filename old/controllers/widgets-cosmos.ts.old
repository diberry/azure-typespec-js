// Cosmos DB implementation of the Widgets interface
import { Widgets, Error } from "../generated/models/all/demo-service.js";
import { ReadWidget } from "../generated/models/all/typespec.js";
import { HttpContext } from "../generated/helpers/router.js";
import { CosmosClientManager, WidgetDocument, CosmosError, buildError } from "../azure/cosmos-client.js";
import type { Container } from "@azure/cosmos";

/**
 * Implementation of the Widgets interface using Azure Cosmos DB
 * Uses DefaultAzureCredential for authentication and follows Azure best practices
 */
export class WidgetsCosmosImpl implements Widgets<HttpContext> {
  private cosmosClientManager: CosmosClientManager;
  private container: Container | null = null;
  private databaseName: string = "WidgetsDb";
  private containerName: string = "Widgets";
  private initialized: boolean = false;

  constructor(cosmosEndpoint: string, databaseName: string, containerName: string) {
    this.databaseName = databaseName;
    this.containerName = containerName;
    this.cosmosClientManager = CosmosClientManager.getInstance();
    this.cosmosClientManager.initialize(cosmosEndpoint);
    this.container = this.cosmosClientManager.getContainer(databaseName || this.databaseName, containerName || this.containerName);
    this.initialized = true;
  }
  /**
   * Convert a Cosmos DB document to a ReadWidget
   */
  private documentToWidget(doc: WidgetDocument): ReadWidget {
    return {
      id: doc.id,
      weight: doc.weight,
      color: doc.color,
    };
  }

  /**
   * List all widgets
   */
  async list(ctx: HttpContext): Promise<ReadWidget[] | Error> {
    
    try{
        const { resources } = await this.container.items
        .query({ query: "SELECT * FROM c" })
        .fetchAll();
      
      return resources.map((doc: WidgetDocument) => this.documentToWidget(doc));

    } catch (error) {
        console.error("Error listing widgets:", error);
        return buildError(error, "Failed to list widgets");
    }
  }

  /**
   * Read a specific widget by ID
   */
  async read(ctx: HttpContext, id: string): Promise<ReadWidget | Error> {
    
    try {
      const { resource } = await this.container.item(id, id).read<WidgetDocument>();
      
      return this.documentToWidget(resource);
    } catch (error) {
      console.error(`Error reading widget ${id}:`, error);
      return buildError(error, `Failed to read widget ${id}`);
    }
  }

  /**
   * Create a new widget
   */
  async create(
    ctx: HttpContext,
    id: string,
    weight: number,
    color: "red" | "blue"
  ): Promise<ReadWidget | Error> {
    
    try {
      // Check if the widget already exists
      const { resource: existingWidget } = await this.container.item(id, id).read<WidgetDocument>();
      
      if (existingWidget) {
        return buildError({statusCode:409}, `Widget with id ${id} already exists`);
      }

      const newWidget: WidgetDocument = { id, weight, color };
      
      // Azure best practice: Using point operations with strong consistency for writes
      const { resource } = await this.container.items.create<WidgetDocument>(newWidget);
      
      return this.documentToWidget(resource);
    } catch (error) {
      console.error(`Error creating widget ${id}:`, error);
      return buildError(error, `Failed to create widget ${id}`);
    }
  }

  /**
   * Delete a widget by ID
   */
  async delete(ctx: HttpContext, id: string): Promise<void | Error> {
    
    try {
      // Check if the widget exists first
      const { resource: existingWidget } = await this.container.item(id, id).read<WidgetDocument>();
      
      if (!existingWidget) {
        return buildError({statusCode:404}, `Widget with id ${id} not found`);
      }

      await this.container.item(id, id).delete();
      
      return;
    } catch (error) {
      console.error(`Error deleting widget ${id}:`, error);
      return buildError(error, `Failed to delete widget ${id}`);
    }
  }
}